/*
 * GUI.java $Id: GUI.java,v 1.8 2003/06/21 13:35:54 Steve Exp $
 *
 * XHTML Validator
 *
 * Public domain application implementation by Mr. Tines <tines@ravnaandtines.com>
 *
 * Version 1.0 (3-May-03)
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $Log: GUI.java,v $
 * Revision 1.8  2003/06/21 13:35:54  Steve
 * Batch validation
 *
 * Revision 1.7  2003/05/19 20:23:12  Steve
 * Echo doctype
 *
 * Revision 1.6  2003/05/18 09:25:02  Steve
 * Improve feedback for cp1252 characters
 *
 * Revision 1.5  2003/05/17 14:56:27  Steve
 * CP1252
 *
 * Revision 1.4  2003/05/06 19:22:37  Steve
 * Usability tweaks + CSS validation
 *
 * Revision 1.3  2003/05/05 14:32:46  Steve
 * Usability enhancements
 *
 */

package com.ravnaandtines.jxhtml;

import java.io.File;
/**
 *
 * @author  Tines
 */
public class GUI extends javax.swing.JFrame {
    
    /** Creates new form GUI */
    public GUI() {
        initComponents();
        jLabel1.setText(java.util.ResourceBundle.getBundle("com/ravnaandtines/jxhtml/properties").getString("Public_domain_application_by_Mr._Tines_<tines@ravnaandtines.com>_Version_1.0"));
        jTextArea2.setRows(20);
        
        String[] schemata = {"1.0 Transitional",
         "1.0 Strict", "1.1", "By Document"};
         for(int i=0; i<schemata.length; ++i)
             schemata[i] = java.util.ResourceBundle.getBundle("com/ravnaandtines/jxhtml/properties").getString(schemata[i]);
         
        javax.swing.DefaultComboBoxModel model = 
            new javax.swing.DefaultComboBoxModel(schemata);
        jComboBox1.setModel(model);
        jComboBox1.setSelectedIndex(3);
        pack();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        jLabel1 = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        jPanel2 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        jComboBox1 = new javax.swing.JComboBox();
        jLabel3 = new javax.swing.JLabel();
        jTextField1 = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jPanel3 = new javax.swing.JPanel();
        folderButton = new javax.swing.JButton();
        recursing = new javax.swing.JCheckBox();

        setTitle(java.util.ResourceBundle.getBundle("com/ravnaandtines/jxhtml/properties").getString("XHTML_Validator"));
        setIconImage(getIconImage());
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                exitForm(evt);
            }
        });

        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel1.setText("Public domain application");
        getContentPane().add(jLabel1, java.awt.BorderLayout.NORTH);

        jPanel1.setLayout(new java.awt.BorderLayout());

        jPanel2.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT));

        jLabel2.setLabelFor(jComboBox1);
        jLabel2.setText(java.util.ResourceBundle.getBundle("com/ravnaandtines/jxhtml/properties").getString("XHTML_Schema:"));
        jPanel2.add(jLabel2);

        jComboBox1.setMaximumRowCount(4);
        jPanel2.add(jComboBox1);

        jLabel3.setLabelFor(jTextField1);
        jLabel3.setText(java.util.ResourceBundle.getBundle("com/ravnaandtines/jxhtml/properties").getString("File:"));
        jPanel2.add(jLabel3);

        jTextField1.setColumns(25);
        jTextField1.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                jTextField1_onFocusLost(evt);
            }
        });

        jTextField1.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                jTextField1_onKeyTyped(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jTextField1_onKeyReleased(evt);
            }
        });

        jPanel2.add(jTextField1);

        jButton1.setText(java.util.ResourceBundle.getBundle("com/ravnaandtines/jxhtml/properties").getString("Browse..."));
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1_onActionPerformed(evt);
            }
        });

        jPanel2.add(jButton1);

        jButton2.setText(java.util.ResourceBundle.getBundle("com/ravnaandtines/jxhtml/properties").getString("Validate"));
        jButton2.setEnabled(false);
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2_onActionPerformed(evt);
            }
        });

        jPanel2.add(jButton2);

        jPanel1.add(jPanel2, java.awt.BorderLayout.NORTH);

        jScrollPane1.setAutoscrolls(true);
        jScrollPane1.setViewportView(jTextArea2);

        jPanel1.add(jScrollPane1, java.awt.BorderLayout.CENTER);

        jPanel3.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT));

        folderButton.setText(java.util.ResourceBundle.getBundle("com/ravnaandtines/jxhtml/properties").getString("Validate_Folder"));
        folderButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                folderButtonActionPerformed(evt);
            }
        });

        jPanel3.add(folderButton);

        recursing.setText(java.util.ResourceBundle.getBundle("com/ravnaandtines/jxhtml/properties").getString("check_sub-folders"));
        jPanel3.add(recursing);

        jPanel1.add(jPanel3, java.awt.BorderLayout.SOUTH);

        getContentPane().add(jPanel1, java.awt.BorderLayout.CENTER);

    }//GEN-END:initComponents

    private void folderButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_folderButtonActionPerformed
        // Add your handling code here:
        javax.swing.JFileChooser chooser = directoryContext == null ?
            new javax.swing.JFileChooser() : 
                new javax.swing.JFileChooser(directoryContext.getParentFile());

        chooser.setFileSelectionMode(javax.swing.JFileChooser.DIRECTORIES_ONLY);
        int returnVal = chooser.showOpenDialog(this);
        if(returnVal == javax.swing.JFileChooser.APPROVE_OPTION) {
            try {
                directoryContext = new File(chooser.getSelectedFile().getCanonicalPath());
            } catch (java.io.IOException e) {return;}
        } else return;
        
        descend(directoryContext);
    }//GEN-LAST:event_folderButtonActionPerformed

    private void descend(File dir)
    {
        XHTMLFileFilter filter = new XHTMLFileFilter();
        File[] targets = dir.listFiles(filter);
        for(int i=0; i<targets.length;++i)
        {
            if(targets[i].isDirectory())
            {
                if(recursing.isSelected())
                {
                    descend(targets[i]);
                }
            }
            else 
                validate(targets[i].toString(), false);
        }        
    }
    
    private java.io.File directoryContext = null;
    
    private void jButton1_onActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1_onActionPerformed
        // Add your handling code here:
        javax.swing.JFileChooser chooser = directoryContext == null ?
            new javax.swing.JFileChooser() : 
                new javax.swing.JFileChooser(directoryContext);
        // Note: source for ExampleFileFilter can be found in FileChooserDemo,
        // under the demo/jfc directory in the Java 2 SDK, Standard Edition.
        XHTMLFileFilter filter = new XHTMLFileFilter();
        chooser.setFileFilter(filter);
        int returnVal = chooser.showOpenDialog(this);
        if(returnVal == javax.swing.JFileChooser.APPROVE_OPTION) {
            try {
            String c = chooser.getSelectedFile().getCanonicalPath();
            jTextField1.setText(c);
            directoryContext = chooser.getSelectedFile().getCanonicalFile().getParentFile();
            } catch (java.io.IOException e) {return;}
        } else return; 
        if(isValidFile())
        {
            jButton2.setEnabled(true);
            jButton2_onActionPerformed(evt);
        }            
    }//GEN-LAST:event_jButton1_onActionPerformed

    private void jButton2_onActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2_onActionPerformed
        // Add your handling code here:
        jTextArea2.setText("");
        validate(jTextField1.getText(), true);
        jTextArea2.setCaretPosition(0);
    }//GEN-LAST:event_jButton2_onActionPerformed

    private void jTextField1_onKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextField1_onKeyReleased
        // Add your handling code here:
        jButton2.setEnabled(isValidFile());                
    }//GEN-LAST:event_jTextField1_onKeyReleased

    private void jTextField1_onKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextField1_onKeyTyped
        // Add your handling code here:
         jButton2.setEnabled(isValidFile());        
    }//GEN-LAST:event_jTextField1_onKeyTyped

    private void jTextField1_onFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jTextField1_onFocusLost
        // Add your handling code here:
        jButton2.setEnabled(isValidFile());    
    }//GEN-LAST:event_jTextField1_onFocusLost
    
    /** Exit the Application */
    private void exitForm(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_exitForm
        System.exit(0);
    }//GEN-LAST:event_exitForm
    

    private void validate(String file, boolean echoDoctype)
    {
        java.io.PrintStream out = System.err;
        long start = jTextArea2.getText().length();
        System.setErr(new TAPS(jTextArea2));        
        try {
        
            try {
                org.apache.xerces.parsers.XML11Configuration config = null;
                switch(jComboBox1.getSelectedIndex())
                {
                    default:
                        config = new XHTML1StrictConfiguration();
                        break;
                    case 0:
                        config = new XHTML1TransitionalConfiguration();
                        break;
                    case 2:
                        config = new XHTML11Configuration();
                        break;
                    case 3:
                        config = new ByDocumentConfiguration();
                        break;
                }
            org.apache.xerces.parsers.SAXParser parser = 
                new org.apache.xerces.parsers.SAXParser(config);
            parser.setFeature("http://xml.org/sax/features/validation", true);
            parser.setContentHandler(new CP1252ScreeningContentHandler(System.err));
            
            java.io.Reader rin = new java.io.FileReader(file);
            if(((java.io.InputStreamReader)rin).getEncoding().equalsIgnoreCase("cp1252"))
            {
                rin.close();
                rin = new RawFileReader(file);
            }
            org.xml.sax.InputSource in = new org.xml.sax.InputSource(rin);
        
            parser.parse(in);
            } catch (Exception e) {
                e.printStackTrace(System.err);
            }
            
            boolean clean = jTextArea2.getText().length() == start;
            if(echoDoctype) jTextArea2.setText(JXHTML.doctype+jTextArea2.getText());
            if(clean)
            {
                System.err.println(
                    java.util.ResourceBundle.getBundle("com/ravnaandtines/jxhtml/properties").getString("Success")
                    );

                Class CssClass = null; 
                java.lang.reflect.Method m = null;
            
                try {
                    CssClass = Class.forName("org.w3c.css.css.StyleSheetCom");
                    Class[] array = new Class[1];
                    //System.out.println(array.getClass().getName());
                    array[0] = Class.forName("[Ljava.lang.String;");
                    m = CssClass.getMethod("main", array);
                } catch (ClassNotFoundException e2) {
                    CssClass = null;
                    //e2.printStackTrace(System.out);//tmp
                } catch (Exception e3) {
                    e3.printStackTrace(System.err);
                    CssClass = null;
                }
                if(CssClass != null && m != null)
                {
                    String[] args = new String[1];
                    args[0] = file;
                    Object[] params = new Object[1];
                    params[0] = args;
                    System.err.flush();
                    java.io.PrintStream save = System.out;
                    System.setOut(System.err);
                    try {
                        System.err.println("");
                        System.err.println(java.util.ResourceBundle.getBundle("com/ravnaandtines/jxhtml/properties").getString("CSS"));
                        m.invoke(null, params);
                    } catch (Exception e4) {
                        e4.printStackTrace(System.err);
                    } finally {
                        System.out.flush();
                        System.setOut(save);
                    }
                }
            }
                        
            System.err.println("");
            System.err.println(file
                +java.util.ResourceBundle.getBundle("com/ravnaandtines/jxhtml/properties").getString("Validation_completed")
                );    
            } finally {
            System.setErr(out);
        }
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        new GUI().show();
    }
    
    public java.awt.Image getIconImage() {
        java.net.URL url = ClassLoader.getSystemResource("jxhtml.gif");
        return java.awt.Toolkit.getDefaultToolkit().createImage(url);
    }    
    
    private boolean isValidFile() {
        java.io.File f = new java.io.File(jTextField1.getText());
        if(f.exists() && f.canRead() && f.isFile())
        {
            try {
            String c = f.getCanonicalPath().toLowerCase();
            return c.endsWith(".html") || c.endsWith(".htm") || c.endsWith(".xml");
            }  catch (java.io.IOException ex) {}
        }
        return false;
    }
    
    public class XHTMLFileFilter extends javax.swing.filechooser.FileFilter 
        implements java.io.FileFilter {
        
        public boolean accept(java.io.File f) {
            if(f.exists() && f.isDirectory())
                return true;
            if(f.exists() && f.canRead() && f.isFile())
            {
                try {
                String c = f.getCanonicalPath().toLowerCase();
                return c.endsWith(".html") || c.endsWith(".htm") || c.endsWith(".xml");
                }   catch (java.io.IOException ex) {}
            }
            return false;
        }
        
        public String getDescription() {
            return java.util.ResourceBundle.getBundle("com/ravnaandtines/jxhtml/properties").getString("XHTML_files");
        }
        
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton2;
    private javax.swing.JTextArea jTextArea2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JCheckBox recursing;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton folderButton;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JComboBox jComboBox1;
    private javax.swing.JTextField jTextField1;
    // End of variables declaration//GEN-END:variables
    
}



class TAOS extends java.io.OutputStream
{
    public TAOS(javax.swing.JTextArea ta)
    {
        area = ta;
    }
    StringBuffer buff = new StringBuffer();
    
    /** Writes the specified byte to this output stream. The general
     * contract for <code>write</code> is that one byte is written
     * to the output stream. The byte to be written is the eight
     * low-order bits of the argument <code>b</code>. The 24
     * high-order bits of <code>b</code> are ignored.
     * <p>
     * Subclasses of <code>OutputStream</code> must provide an
     * implementation for this method.
     *
     * @param      b   the <code>byte</code>.
     * @exception  IOException  if an I/O error occurs. In particular,
     *             an <code>IOException</code> may be thrown if the
     *             output stream has been closed.
     *
     */
    public void write(int b) throws java.io.IOException {
        buff.append((char)(b&0xFF));
        if(b == '\r' || b == '\n')
        {
            area.append(buff.toString());
            buff = new StringBuffer();
        }
    }
    
    javax.swing.JTextArea area = null;
}

class TAPS extends java.io.PrintStream
{
    public TAPS(javax.swing.JTextArea ta)
    {
        super(new TAOS(ta));
    }
}

class CP1252ScreeningContentHandler implements org.xml.sax.ContentHandler
{
    public CP1252ScreeningContentHandler(java.io.PrintStream out)
    {
        this.out = out;
    }
    private java.io.PrintStream out;
    
    /** Receive notification of character data.
     *
     * <p>The Parser will call this method to report each chunk of
     * character data.  SAX parsers may return all contiguous character
     * data in a single chunk, or they may split it into several
     * chunks; however, all of the characters in any single event
     * must come from the same external entity so that the Locator
     * provides useful information.</p>
     *
     * <p>The application must not attempt to read from the array
     * outside of the specified range.</p>
     *
     * <p>Note that some parsers will report whitespace in element
     * content using the {@link #ignorableWhitespace ignorableWhitespace}
     * method rather than this one (validating parsers <em>must</em>
     * do so).</p>
     *
     * @param ch The characters from the XML document.
     * @param start The start position in the array.
     * @param length The number of characters to read from the array.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #ignorableWhitespace
     * @see org.xml.sax.Locator
     *
     */
    public void characters(char[] ch, int start, int length) throws org.xml.sax.SAXException {
        boolean clean = true;
        for(int i=0; i<length; ++i)
        {
            if(ch[i] >= 0x80 && ch[i] < 0xa0)
            {
                clean = false;
                Object[] args = {
                    ""+codepoints[ch[i]-0x80],
                    Integer.toHexString(ch[i]),
                    Integer.toString(ch[i]), unicode[ch[i]-0x80]};
                String result = java.text.MessageFormat.format(
                    java.util.ResourceBundle.getBundle("com/ravnaandtines/jxhtml/properties").getString("cp1252"),
                    args);
                out.println(result);
            }                    
        }
        if(locator != null && !clean)
        {
            Object[] args = {
                    Integer.toString(locator.getLineNumber()),
                    Integer.toString(locator.getColumnNumber())};
                String result = java.text.MessageFormat.format(
                    java.util.ResourceBundle.getBundle("com/ravnaandtines/jxhtml/properties").getString("Location"),
                    args);
                out.println(result);
        }
        if(!clean)
            System.err.println("");
    }
    
    public static final String [] unicode = {
    "&euro;","?","&sbquo;","&fnof;",
    "&bdquo;","&hellip;","&dagger;","&Dagger;",
    "&circ;","&permil;","&Scaron;","&lsaquo;",
    "&OElig;","?","&#x017d;","?",
    "?","&lsquo;","&rsquo;","&ldquo;",
    "&rdquo;","&bull;","&ndash;","&mdash;",
    "&tilde;","&trade;","&scaron;","&rsaquo;",
    "&oelig;","?","&#x017e;","&Yuml;" };
    
    public static final char[] codepoints = {
         0x20AC, '?'/*0x0081*/, 0x201A, 0x0192, 
         0x201E, 0x2026, 0x2020, 0x2021, 
         0x02C6, 0x2030, 0x0160, 0x2039, 
         0x0152, '?'/*0x008D*/, 0x017D, '?'/*0x008F*/, 
         '?'/*0x0090*/, 0x2018, 0x2019, 0x201C, 
         0x201D, 0x2022, 0x2013, 0x2014, 
         0x02DC, 0x2122, 0x0161, 0x203A, 
         0x0153, '?'/*0x009D*/, 0x017E, 0x0178
    };
    
    
    /** Receive notification of the end of a document.
     *
     * <p>The SAX parser will invoke this method only once, and it will
     * be the last method invoked during the parse.  The parser shall
     * not invoke this method until it has either abandoned parsing
     * (because of an unrecoverable error) or reached the end of
     * input.</p>
     *
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #startDocument
     *
     */
    public void endDocument() throws org.xml.sax.SAXException {
    }
    
    /** Receive notification of the end of an element.
     *
     * <p>The SAX parser will invoke this method at the end of every
     * element in the XML document; there will be a corresponding
     * {@link #startElement startElement} event for every endElement
     * event (even when the element is empty).</p>
     *
     * <p>For information on the names, see startElement.</p>
     *
     * @param uri The Namespace URI, or the empty string if the
     *        element has no Namespace URI or if Namespace
     *        processing is not being performed.
     * @param localName The local name (without prefix), or the
     *        empty string if Namespace processing is not being
     *        performed.
     * @param qName The qualified XML 1.0 name (with prefix), or the
     *        empty string if qualified names are not available.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     *
     */
    public void endElement(String namespaceURI, String localName, String qName) throws org.xml.sax.SAXException {
    }
    
    /** End the scope of a prefix-URI mapping.
     *
     * <p>See {@link #startPrefixMapping startPrefixMapping} for
     * details.  This event will always occur after the corresponding
     * {@link #endElement endElement} event, but the order of
     * {@link #endPrefixMapping endPrefixMapping} events is not otherwise
     * guaranteed.</p>
     *
     * @param prefix The prefix that was being mapping.
     * @exception org.xml.sax.SAXException The client may throw
     *            an exception during processing.
     * @see #startPrefixMapping
     * @see #endElement
     *
     */
    public void endPrefixMapping(String prefix) throws org.xml.sax.SAXException {
    }
    
    /** Receive notification of ignorable whitespace in element content.
     *
     * <p>Validating Parsers must use this method to report each chunk
     * of whitespace in element content (see the W3C XML 1.0 recommendation,
     * section 2.10): non-validating parsers may also use this method
     * if they are capable of parsing and using content models.</p>
     *
     * <p>SAX parsers may return all contiguous whitespace in a single
     * chunk, or they may split it into several chunks; however, all of
     * the characters in any single event must come from the same
     * external entity, so that the Locator provides useful
     * information.</p>
     *
     * <p>The application must not attempt to read from the array
     * outside of the specified range.</p>
     *
     * @param ch The characters from the XML document.
     * @param start The start position in the array.
     * @param length The number of characters to read from the array.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #characters
     *
     */
    public void ignorableWhitespace(char[] ch, int start, int length) throws org.xml.sax.SAXException {
    }
    
    /** Receive notification of a processing instruction.
     *
     * <p>The Parser will invoke this method once for each processing
     * instruction found: note that processing instructions may occur
     * before or after the main document element.</p>
     *
     * <p>A SAX parser must never report an XML declaration (XML 1.0,
     * section 2.8) or a text declaration (XML 1.0, section 4.3.1)
     * using this method.</p>
     *
     * @param target The processing instruction target.
     * @param data The processing instruction data, or null if
     *        none was supplied.  The data does not include any
     *        whitespace separating it from the target.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     *
     */
    public void processingInstruction(String target, String data) throws org.xml.sax.SAXException {
    }
    
    /** Receive an object for locating the origin of SAX document events.
     *
     * <p>SAX parsers are strongly encouraged (though not absolutely
     * required) to supply a locator: if it does so, it must supply
     * the locator to the application by invoking this method before
     * invoking any of the other methods in the ContentHandler
     * interface.</p>
     *
     * <p>The locator allows the application to determine the end
     * position of any document-related event, even if the parser is
     * not reporting an error.  Typically, the application will
     * use this information for reporting its own errors (such as
     * character content that does not match an application's
     * business rules).  The information returned by the locator
     * is probably not sufficient for use with a search engine.</p>
     *
     * <p>Note that the locator will return correct information only
     * during the invocation of the events in this interface.  The
     * application should not attempt to use it at any other time.</p>
     *
     * @param locator An object that can return the location of
     *                any SAX document event.
     * @see org.xml.sax.Locator
     *
     */
    public void setDocumentLocator(org.xml.sax.Locator locator) {
        this.locator = locator;
    }
    org.xml.sax.Locator locator = null;
    
    /** Receive notification of a skipped entity.
     *
     * <p>The Parser will invoke this method once for each entity
     * skipped.  Non-validating processors may skip entities if they
     * have not seen the declarations (because, for example, the
     * entity was declared in an external DTD subset).  All processors
     * may skip external entities, depending on the values of the
     * <code>http://xml.org/sax/features/external-general-entities</code>
     * and the
     * <code>http://xml.org/sax/features/external-parameter-entities</code>
     * properties.</p>
     *
     * @param name The name of the skipped entity.  If it is a
     *        parameter entity, the name will begin with '%', and if
     *        it is the external DTD subset, it will be the string
     *        "[dtd]".
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     *
     */
    public void skippedEntity(String name) throws org.xml.sax.SAXException {
    }
    
    /** Receive notification of the beginning of a document.
     *
     * <p>The SAX parser will invoke this method only once, before any
     * other methods in this interface or in {@link org.xml.sax.DTDHandler
     * DTDHandler} (except for {@link #setDocumentLocator
     * setDocumentLocator}).</p>
     *
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #endDocument
     *
     */
    public void startDocument() throws org.xml.sax.SAXException {
    }
    
    /** Receive notification of the beginning of an element.
     *
     * <p>The Parser will invoke this method at the beginning of every
     * element in the XML document; there will be a corresponding
     * {@link #endElement endElement} event for every startElement event
     * (even when the element is empty). All of the element's content will be
     * reported, in order, before the corresponding endElement
     * event.</p>
     *
     * <p>This event allows up to three name components for each
     * element:</p>
     *
     * <ol>
     * <li>the Namespace URI;</li>
     * <li>the local name; and</li>
     * <li>the qualified (prefixed) name.</li>
     * </ol>
     *
     * <p>Any or all of these may be provided, depending on the
     * values of the <var>http://xml.org/sax/features/namespaces</var>
     * and the <var>http://xml.org/sax/features/namespace-prefixes</var>
     * properties:</p>
     *
     * <ul>
     * <li>the Namespace URI and local name are required when
     * the namespaces property is <var>true</var> (the default), and are
     * optional when the namespaces property is <var>false</var> (if one is
     * specified, both must be);</li>
     * <li>the qualified name is required when the namespace-prefixes property
     * is <var>true</var>, and is optional when the namespace-prefixes property
     * is <var>false</var> (the default).</li>
     * </ul>
     *
     * <p>Note that the attribute list provided will contain only
     * attributes with explicit values (specified or defaulted):
     * #IMPLIED attributes will be omitted.  The attribute list
     * will contain attributes used for Namespace declarations
     * (xmlns* attributes) only if the
     * <code>http://xml.org/sax/features/namespace-prefixes</code>
     * property is true (it is false by default, and support for a
     * true value is optional).</p>
     *
     * @param uri The Namespace URI, or the empty string if the
     *        element has no Namespace URI or if Namespace
     *        processing is not being performed.
     * @param localName The local name (without prefix), or the
     *        empty string if Namespace processing is not being
     *        performed.
     * @param qName The qualified name (with prefix), or the
     *        empty string if qualified names are not available.
     * @param atts The attributes attached to the element.  If
     *        there are no attributes, it shall be an empty
     *        Attributes object.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #endElement
     * @see org.xml.sax.Attributes
     *
     */
    public void startElement(String namespaceURI, String localName, String qName, 
        org.xml.sax.Attributes atts) throws org.xml.sax.SAXException {
    }
    
    /** Begin the scope of a prefix-URI Namespace mapping.
     *
     * <p>The information from this event is not necessary for
     * normal Namespace processing: the SAX XML reader will
     * automatically replace prefixes for element and attribute
     * names when the <code>http://xml.org/sax/features/namespaces</code>
     * feature is <var>true</var> (the default).</p>
     *
     * <p>There are cases, however, when applications need to
     * use prefixes in character data or in attribute values,
     * where they cannot safely be expanded automatically; the
     * start/endPrefixMapping event supplies the information
     * to the application to expand prefixes in those contexts
     * itself, if necessary.</p>
     *
     * <p>Note that start/endPrefixMapping events are not
     * guaranteed to be properly nested relative to each-other:
     * all startPrefixMapping events will occur before the
     * corresponding {@link #startElement startElement} event,
     * and all {@link #endPrefixMapping endPrefixMapping}
     * events will occur after the corresponding {@link #endElement
     * endElement} event, but their order is not otherwise
     * guaranteed.</p>
     *
     * <p>There should never be start/endPrefixMapping events for the
     * "xml" prefix, since it is predeclared and immutable.</p>
     *
     * @param prefix The Namespace prefix being declared.
     * @param uri The Namespace URI the prefix is mapped to.
     * @exception org.xml.sax.SAXException The client may throw
     *            an exception during processing.
     * @see #endPrefixMapping
     * @see #startElement
     *
     */
    public void startPrefixMapping(String prefix, String uri) throws org.xml.sax.SAXException {
    }
    
}

class RawFileReader extends java.io.Reader {
    
    java.io.FileInputStream fin = null;
    public RawFileReader(String file)
        throws java.io.FileNotFoundException
    {
        fin = new java.io.FileInputStream(file);
    }
    
    /** Close the stream.  Once a stream has been closed, further read(),
     * ready(), mark(), or reset() invocations will throw an IOException.
     * Closing a previously-closed stream, however, has no effect.
     *
     * @exception  IOException  If an I/O error occurs
     *
     */
    public void close() throws java.io.IOException {
        fin.close();
    }
    
    /** Read characters into a portion of an array.  This method will block
     * until some input is available, an I/O error occurs, or the end of the
     * stream is reached.
     *
     * @param      cbuf  Destination buffer
     * @param      off   Offset at which to start storing characters
     * @param      len   Maximum number of characters to read
     *
     * @return     The number of characters read, or -1 if the end of the
     *             stream has been reached
     *
     * @exception  IOException  If an I/O error occurs
     *
     */
    public int read(char[] cbuf, int off, int len) throws java.io.IOException {
        if(len > buf.length) buf = new byte[len];
        
        int n = fin.read(buf, 0, len);
        int i;
        for(i=0; i<n; ++i)
        {
            cbuf[off+i] = (char)(0xFF & buf[i]);
        }
        for(i=0; i<n; ++i)
        {
            if(cbuf[off+i] >= 0x80 && cbuf[off+i] < 0xa0)
            {
                Object[] args = {""+CP1252ScreeningContentHandler.codepoints[cbuf[off+i]-0x80],
                    Integer.toHexString(cbuf[off+i]), 
                    CP1252ScreeningContentHandler.unicode[cbuf[off+i]-0x80]};
                String format = 
                    java.util.ResourceBundle.getBundle("com/ravnaandtines/jxhtml/properties").getString("cp1252raw");
                String result = java.text.MessageFormat.format(format, args);
                System.err.println(result);
                int slack = 20;
                int from = i>slack ? i-slack : 0;
                int to = i+slack > n ? n : i+slack;
                char[] context = new char[to-from];
                for(int j=0; j<context.length; ++j)
                {
                    context[j] = cbuf[off+from+j];
                    if(context[j] >= 0x80 && context[j] < 0xa0)
                        context[j] = CP1252ScreeningContentHandler.codepoints[context[j]-0x80];
                }
                
                System.err.println(new String(context));
                System.err.println("");
            }                    
        }
        return n;
    }
    private byte[] buf = new byte[1024];
}
